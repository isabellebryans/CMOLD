@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xs:   <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/chess/>.
@prefix sh: <http://www.w3.org/ns/shacl#>.


# Still to implement:
# - if white piece captures a piece, it must be black
# - queen, bishop, rook can move as many spaces as long as there are no pieces in the way
# - Only one piece moved at a time ( or two if one was captured ) -> can't do this
# - Pawn can move more than one space first move
# - Pawn can transfer into a different piece when it reaches otherside

# At most one chess piece on each tile at t1 and t2
:atMostOne
    a sh:NodeShape ;
    sh:targetClass :tile;
    sh:property [
          sh:path [sh:inversePath :isIn_t1];
          sh:maxCount 1;
          sh:class :ChessPiece;
          sh:message "Tile contains more than one chess piece"];
    sh:property [
                    sh:path [sh:inversePath :isIn_t2];
                    sh:maxCount 1;
                    sh:class :ChessPiece;
                    sh:message "Tile contains more than one chess piece"].




# Every chess piece is either on a tile or out
# Stops players from moving a piece to a tile that doesn't exist (off the chess board)
:pieceShape
    a sh:NodeShape ;
    sh:targetClass :ChessPiece;
    sh:message "Piece is not in a position";
    sh:property [
                sh:path :isIn_t1;
                sh:message "Piece is not in a position";
                sh:or(
                        [ sh:class :tile ]
                        [ sh:hasValue :out ]
                     )
                ];
    sh:property [
                sh:path :isIn_t2;
                sh:message "Piece is not in a position";
                sh:or(
                        [ sh:class :tile ]
                        [ sh:hasValue :out ]
                     )
                ].


# Pawn Move Validation
# Option 1: Pawn has not moved
# Option 2: Pawn has moved one space forward
# Option 3: Pawn has moved one space forward diagonally and has captured a piece
# Option 4: Pawn has been captured
:PawnMove
    a sh:NodeShape ;
    sh:targetClass :Pawn;
    sh:message "Invalid pawn move";
    sh:or(
            [sh:property :PieceNotMoved ]
            [
                    # Option 2: Pawn has moved one space in front and did not capture any piece
                    sh:property [
                        sh:path (:isIn_t1 :above );
                        sh:equals :isIn_t2;
                                ];
                    sh:property [
                                sh:path :isIn_t2;
                                sh:property [
                                            sh:path [sh:inversePath :isIn_t1];
                                            sh:maxCount 0;
                                            ]
                                ];
            ]

            [
                # Option 3: Pawn has moved one space in front diagonally and captured a piece
                sh:or(
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :tr );
                                            sh:class :tile;
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :tl );
                                            sh:class :tile;
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                     );
                sh:property [
                            sh:path :isIn_t2;
                            sh:property [
                                        sh:path [sh:inversePath :isIn_t1];
                                        sh:minCount 1;
                                        sh:property [
                                                        sh:path :isIn_t2;
                                                        sh:hasValue :out;]
                                    ]
                            ]
            ]
            [
                # Option 4: Pawn is captured
            sh:node :hasBeenCaptured ;
            ]
         )
    .


# Rook Move Validation
# Option 1: Rook has not moved
# Option 2: Rook has moved forward, backward, right or left
#           (Optional: Can have captured a piece or not)
# Option 3: Rook has been captured
:RookMove
    a sh:NodeShape ;
    sh:targetClass :Rook, :Queen;
    sh:message "Invalid rook/queen move";
    sh:or(
            [
                  sh:property :PieceNotMoved ;
            ]
            [
                    # Option 2: Rook has moved forward, backward, right or left
                sh:or(
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :above );
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :below );
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :right );
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :left );
                                            sh:equals :isIn_t2;
                                        ];
                        ]

                     );
                    # Has the option to have captured a piece or not
                    sh:or(
                             [
                                 # There was no piece captured
                                 # This works
                                 sh:path [sh:inversePath :isIn_t1];
                                 sh:maxCount 0;
                             ]
                             [
                                 # There was a piece captured
                                 # this works
                                 sh:property [
                                                 sh:path[sh:inversePath :isIn_t1];
                                                 sh:minCount 1;
                                                 sh:property [
                                                            sh:path :isIn_t2;
                                                            sh:hasValue :out;]
                                             ]
                             ]
                         )
            ]
            [
                # Option 3: Rook is captured
                sh:node :hasBeenCaptured ;
            ]
         ).


# Bishop move validation
# Option 1: Bishop didn't move
# Option 2: Bishop moved tl, tr, br, bl
#           (Optionally captured a piece)
# Option 3: Bishop was captured
:BishopMove
    a sh:NodeShape ;
    sh:targetClass :Bishop;
    sh:message "Invalid bishop move";
    sh:or(
          [
              # Option 1: Bishop has not moved
              sh:path :isIn_t1 ;
              sh:equals :isIn_t2;
          ]
          [
              # Option 2: Bishop has moved tr, tl, br, bl
              sh:or(
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :tr );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :tl );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :br );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :bl );
                                           sh:equals :isIn_t2;
                                       ];
                       ]

                   );
              # Has the option to have captured a piece or not
              sh:or(
                       [
                           # There was no piece captured
                           # This works
                           sh:path [sh:inversePath :isIn_t1];
                           sh:maxCount 0;
                       ]
                       [
                           # There was a piece captured
                           # this works
                           sh:property [
                                           sh:path[sh:inversePath :isIn_t1];
                                           sh:minCount 1;
                                           sh:property [
                                                      sh:path :isIn_t2;
                                                      sh:hasValue :out;]
                                       ]
                       ]
                   )
          ]
          [
              # Option 3: Bishop is captured
              sh:property [
                              sh:path :isIn_t2;
                              sh:hasValue :out;
                          ];
              sh:property [
                              sh:path :isIn_t1;
                              sh:property [
                                          sh:path [sh:inversePath :isIn_t2];
                                          sh:minCount 1;
                                      ]
                          ]
          ]
      ).


# King Move Validation
# Option 1: King has not moved
# Option 2: King has moved forward, backward, right or left
#           (Optional: Can have captured a piece or not)
:KingMove
    a sh:NodeShape ;
    sh:targetClass :King;
    sh:message "Invalid king move";
    sh:or(
          [
              # Option 1: King has not moved
              sh:path :isIn_t1 ;
              sh:equals :isIn_t2;
          ]
          [
              # Option 2: King has moved forward, backward, right or left
              sh:or(
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :above );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :below );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :right );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :left );
                                           sh:equals :isIn_t2;
                                       ];
                       ]

                   );
              # Has the option to have captured a piece or not
              sh:property [
                              sh:path :isIn_t2;
                              sh:hasValue :out;
                          ];
              sh:property [
                              sh:path :isIn_t1;
                              sh:property [
                                          sh:path [sh:inversePath :isIn_t2];
                                          sh:minCount 1;
                                      ]
                          ]
          ]
      ).



# Knight move validation
# Option 1: Move tl, then above or left
# Option 2: Move tr, then above or right
# Option 3: Move br, the below or right
# Option 4: Move bl, then below or left
#           (Optionally capture piece)
# Option 5: Be captured
:KnightMove
    a sh:NodeShape ;
    sh:targetClass :Knight;
    sh:message "Invalid knight move";
    sh:or (
            [
                # Option 1: Knight has not moved
                sh:path :isIn_t1 ;
                sh:equals :isIn_t2 ;
            ]
            [
                sh:or(
                        [
                            sh:path (:isIn_t1 :tr :above);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :tr :right);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :tl :above);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :tl :left);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :bl :below);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :bl :left);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :br :below);
                            sh:equals :isIn_t2;
                        ]
                        [
                            sh:path (:isIn_t1 :br :right);
                            sh:equals :isIn_t2;
                        ]
                     );

                    # Has the option to have captured a piece or not
                sh:or(
                         [
                             # There was no piece captured
                             # This works
                             sh:path [sh:inversePath :isIn_t1];
                             sh:maxCount 0;
                         ]
                         [
                             # There was a piece captured
                             # this works
                             sh:property [
                                             sh:path[sh:inversePath :isIn_t1];
                                             sh:minCount 1;
                                             sh:property [
                                                        sh:path :isIn_t2;
                                                        sh:hasValue :out;]
                                         ]
                         ]
                     )

            ]
            [
                # Option 3: Knight is captured
                sh:property [
                                sh:path :isIn_t2;
                                sh:hasValue :out;
                            ];
                sh:property [
                                sh:path :isIn_t1;
                                sh:property [
                                            sh:path [sh:inversePath :isIn_t2];
                                            sh:minCount 1;
                                        ]
                            ]
            ]
    ).



:PieceNotMoved
    a sh:PropertyShape ;
    sh:path :isIn_t1;
    sh:equals :isIn_t2.

# Piece can either have captured a piece or not
:CapturedPiece
    a sh:PropertyShape ;
    sh:path :isIn_t2;
    sh:or(
          [
              # There was no piece captured
              # This works
              sh:path [sh:inversePath :isIn_t1];
              sh:maxCount 0;
          ]
          [
              # There was a piece captured
              # this works
              sh:property [
                              sh:path[sh:inversePath :isIn_t1];
                              sh:minCount 1;
                              sh:property [
                                         sh:path :isIn_t2;
                                         sh:hasValue :out;]
                          ]
          ]
      ).

:hasBeenCaptured
    a sh:NodeShape ;
    sh:property [
          sh:path :isIn_t2;
          sh:hasValue :out;
      ];
    sh:property [
          sh:path :isIn_t1;
          sh:property [
                      sh:path [sh:inversePath :isIn_t2];
                      sh:minCount 1;
                  ]
      ].
