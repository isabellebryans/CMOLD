@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xs:   <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/chess/>.
@prefix sh: <http://www.w3.org/ns/shacl#>.

# At most one chess piece on each tile at t1 and t2
:atMostOne
    a sh:NodeShape ;
    sh:targetClass :tile;
    sh:property [
          sh:path [sh:inversePath :isIn_t1];
          sh:maxCount 1;
          sh:class :ChessPiece;
          sh:message "Tile contains more than one chess piece"];
    sh:property [
                    sh:path [sh:inversePath :isIn_t2];
                    sh:maxCount 1;
                    sh:class :ChessPiece;
                    sh:message "Tile contains more than one chess piece"].


# Pawn Move Validation
# Option 1: Pawn has not moved
# Option 2: Pawn has moved one space forward
# Option 3: Pawn has moved one space forward diagonally and has captured a piece
# Option 4: Pawn has been captured
:PawnMove
    a sh:NodeShape ;
    sh:targetClass :Pawn;
    sh:message "Invalid pawn move";
    sh:or(
            [
                    # Option 1: Pawn hasn't moved
            sh:path :isIn_t1 ;
            sh:equals :isIn_t2 ; ]
            [
                    # Option 2: Pawn has moved one space in front and did not capture any piece
                    sh:property [
                        sh:path (:isIn_t1 :above );
                        sh:equals :isIn_t2;
                                ];
                    sh:property [
                                sh:path :isIn_t2;
                                sh:property [
                                            sh:path [sh:inversePath :isIn_t1];
                                            sh:maxCount 0;
                                            ]
                                ];
            ]

            [
                # Option 3: Pawn has moved one space in front diagonally and captured a piece
                sh:or(
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :tr );
                                            sh:class :tile;
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :tl );
                                            sh:class :tile;
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                     );
                sh:property [
                            sh:path :isIn_t2;
                            sh:property [
                                        sh:path [sh:inversePath :isIn_t1];
                                    sh:minCount 1;
                                    ]
                            ]
            ]
            [
                # Option 4: Pawn is captured
                sh:property [
                                sh:path :isIn_t2;
                                sh:hasValue :out;
                            ];
                sh:property [
                            sh:path :isIn_t1;
                            sh:property [
                                        sh:path [sh:inversePath :isIn_t2];
                                        sh:minCount 1;
                                        ]
                            ]
            ]
         )
    .


# Or statement:
# 1. isIn_t1 and isIn_t2 is same tile
# 2. isIn_t2 to the left is the tile of isIn_t2
# 3. right, above, below
:RookMove
    a sh:NodeShape ;
    sh:targetClass :Rook;
    sh:or(
            [
            sh:path :isIn_t1 ;
            sh:equals :isIn_t2;
            ]
            [
            sh:path :isIn_t1;
                    sh:node[
                           sh:property [
                                       sh:path :right;
                                       sh:node[
                                              sh:property [
                                                          sh:path [sh:inversePath :isIn_t2];
                                                          sh:equals sh:isIn_t1;
                                                          ]]]
                           ]
            ]
         ).

