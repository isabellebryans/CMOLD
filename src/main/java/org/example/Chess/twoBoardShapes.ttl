@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xs:   <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/chess/>.
@prefix sh: <http://www.w3.org/ns/shacl#>.

# At most one chess piece on each tile at t1 and t2
:atMostOne
    a sh:NodeShape ;
    sh:targetClass :tile;
    sh:property [
          sh:path [sh:inversePath :isIn_t1];
          sh:maxCount 1;
          sh:class :ChessPiece;
          sh:message "Tile contains more than one chess piece"];
    sh:property [
                    sh:path [sh:inversePath :isIn_t2];
                    sh:maxCount 1;
                    sh:class :ChessPiece;
                    sh:message "Tile contains more than one chess piece"].

# Every chess piece is either on a tile or out
# Stops players from moving a piece to a tile that doesn't exist (off the chess board)
:pieceShape
    a sh:NodeShape ;
    sh:targetClass :ChessPiece;
    sh:message "Piece is not in a position";
    sh:property [
                sh:path :isIn_t1;
                sh:or(
                        [ sh:class :tile ]
                        [ sh:hasValue :out ]
                     )
                ];
    sh:property [
                sh:path :isIn_t2;
                sh:or(
                        [ sh:class :tile ]
                        [ sh:hasValue :out ]
                     )
                ].


# Pawn Move Validation
# Option 1: Pawn has not moved
# Option 2: Pawn has moved one space forward
# Option 3: Pawn has moved one space forward diagonally and has captured a piece
# Option 4: Pawn has been captured
:PawnMove
    a sh:NodeShape ;
    sh:targetClass :Pawn;
    sh:message "Invalid pawn move";
    sh:or(
            [
                    # Option 1: Pawn hasn't moved
            sh:path :isIn_t1 ;
            sh:equals :isIn_t2 ; ]
            [
                    # Option 2: Pawn has moved one space in front and did not capture any piece
                    sh:property [
                        sh:path (:isIn_t1 :above );
                        sh:equals :isIn_t2;
                                ];
                    sh:property [
                                sh:path :isIn_t2;
                                sh:property [
                                            sh:path [sh:inversePath :isIn_t1];
                                            sh:maxCount 0;
                                            ]
                                ];
            ]

            [
                # Option 3: Pawn has moved one space in front diagonally and captured a piece
                sh:or(
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :tr );
                                            sh:class :tile;
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :tl );
                                            sh:class :tile;
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                     );
                sh:property [
                            sh:path :isIn_t2;
                            sh:property [
                                        sh:path [sh:inversePath :isIn_t1];
                                        sh:minCount 1;
                                        sh:property [
                                                        sh:path :isIn_t2;
                                                        sh:hasValue :out;]
                                    ]
                            ]
            ]
            [
                # Option 4: Pawn is captured
                sh:property [
                                sh:path :isIn_t2;
                                sh:hasValue :out;
                            ];
                sh:property [
                            sh:path :isIn_t1;
                            sh:property [
                                        sh:path [sh:inversePath :isIn_t2];
                                        sh:minCount 1;
                                        ]
                            ]
            ]
         )
    .


# Rook Move Validation
# Option 1: Rook has not moved
# Option 2: Rook has moved forward, backward, right or left
#           (Optional: Can have captured a piece or not)
# Option 3: Rook has been captured
:RookMove
    a sh:NodeShape ;
    sh:targetClass :Rook, :Queen;
    sh:message "Invalid rook/queen move";
    sh:or(
            [
                    # Option 1: Rook has not moved
            sh:path :isIn_t1 ;
            sh:equals :isIn_t2;
            ]
            [
                    # Option 2: Rook has moved forward, backward, right or left
                sh:or(
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :above );
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :below );
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :right );
                                            sh:equals :isIn_t2;
                                        ];
                        ]
                        [
                            sh:property [
                                            sh:path (:isIn_t1 :left );
                                            sh:equals :isIn_t2;
                                        ];
                        ]

                     );
                    # Has the option to have captured a piece or not
                sh:property [
                    sh:path :isIn_t2;
                        sh:or(
                                [
                                        # There was no piece captured
                                        # This works
                                        sh:path [sh:inversePath :isIn_t1];
                                        sh:maxCount 0;
                                ]
                                [
                                        # There was a piece captured
                                        # this works
                                        sh:property [
                                                        sh:path[sh:inversePath :isIn_t1];
                                                        sh:minCount 1;
                                                        sh:property [
                                                                    sh:path :isIn_t2;
                                                                    sh:hasValue :out;]
                                                    ]
                                        ]
                             )
                ]
            ]
            [
                # Option 3: Rook is captured
                sh:property [
                                sh:path :isIn_t2;
                                sh:hasValue :out;
                            ];
                sh:property [
                                sh:path :isIn_t1;
                                sh:property [
                                            sh:path [sh:inversePath :isIn_t2];
                                            sh:minCount 1;
                                        ]
                            ]
            ]
         ).


# King Move Validation
# Option 1: King has not moved
# Option 2: King has moved forward, backward, right or left
#           (Optional: Can have captured a piece or not)
:KingMove
    a sh:NodeShape ;
    sh:targetClass :King;
    sh:message "Invalid king move";
    sh:or(
          [
              # Option 1: King has not moved
              sh:path :isIn_t1 ;
              sh:equals :isIn_t2;
          ]
          [
              # Option 2: King has moved forward, backward, right or left
              sh:or(
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :above );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :below );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :right );
                                           sh:equals :isIn_t2;
                                       ];
                       ]
                       [
                           sh:property [
                                           sh:path (:isIn_t1 :left );
                                           sh:equals :isIn_t2;
                                       ];
                       ]

                   );
              # Has the option to have captured a piece or not
              sh:property [
                       sh:path :isIn_t2;
                       sh:or(
                                   [
                                       # There was no piece captured
                                       # This works
                                       sh:path [sh:inversePath :isIn_t1];
                                       sh:maxCount 0;
                                   ]
                                   [
                                       # There was a piece captured
                                       # this works
                                       sh:property [
                                                       sh:path[sh:inversePath :isIn_t1];
                                                       sh:minCount 1;
                                                       sh:property [
                                                                  sh:path :isIn_t2;
                                                                  sh:hasValue :out;]
                                                   ]
                                   ]
                               )
                   ]
          ]
      ).



# Knight move validation
# Option 1: Moved
:KnightMove
    a sh:NodeShape ;
    sh:targetClass :Knight.