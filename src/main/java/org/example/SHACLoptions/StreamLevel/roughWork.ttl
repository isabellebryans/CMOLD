@prefix rdf:  <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xs:   <http://www.w3.org/2001/XMLSchema#> .
@prefix : <http://example.org/>.
@prefix sh: <http://www.w3.org/ns/shacl#> .
sh:property [sh:path :movement;
                sh:in(:diagonal :straight);
                sh:minCount 1;
                ];
    sh:property [sh:path :direction;
                 sh:in(:north :south);
                 sh:minCount 1;
                ];
    sh:property [sh:path :direction;
                 sh:in(:diagonal :straight);
                 sh:minCount 1;
                ];
    sh:property [sh:path :noSpaces;
                 sh:datatype xs:integer;
].

sh:property [
                    sh:path :to;
                    sh:class :position;
                    sh:qualifiedValueShape [
                            # need to find way to see if the place was previously empty
                                           sh:path :occupied;
                                           sh:hasValue :yes; # if the position node now has two paths of :contains, the other one is dead
                                           ];
                            # if had variable , we would be able to make a new shape to see wwwhich one iss killed                                           ];
                    sh:qualifiedMinCount 1;
                    sh:qualifiedValueShape [
                                           sh:or(
                                           [ sh:path :contains;
                                               sh:maxCount 1;
                                               sh:class :queen; # could use variable here

                                           ]
                                           [ sh:path :contains;
                                               sh:minCount 2;
                                               sh:maxCount 2;
                                               sh:qualifiedValueShape [
                                                    sh:path :state;
                                                    sh:hasValue :dead;
                                               ]
                                               sh:qualifiedMinCount 1;
                                               sh:qualifiedMaxCount 1;
                                           ]
                                           )

                                           ];
                    sh:qualifiedMinCount 1;
                    sh:minCount 1;
        sh:maxCount 1;
].

# Shape to make sure each queen piece has a new position which is a position and the position now contains a queen

:queenShape
    a sh:NodeShape ;
    sh:targetClass :queen;
    sh:property [sh:path :newPosition;
                 sh:class :position;
                 sh:qualifiedValueShape [
                             sh:path :contains;
                             sh:class   :queen;
                         ];
                 sh:qualifiedMinCount 1;
      ].